# SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
# SPDX-FileCopyrightText: 2025 Aidenkrz <28298836+Aidenkrz@users.noreply.github.com>
# SPDX-FileCopyrightText: 2025 Lachryphage (GitHub)
# SPDX-FileCopyrightText: 2025 sleepyyapril <123355664+sleepyyapril@users.noreply.github.com>
# SPDX-FileCopyrightText: 2025 sleepyyapril <flyingkarii@gmail.com>
# SPDX-FileCopyrightText: 2025 ReboundQ3 <ReboundQ3@gmail.com>
#
# SPDX-License-Identifier: MIT

name: Update REUSE Headers

on:
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

# Avoid piling up duplicate runs for the same PR.
concurrency:
  group: reuse-updater-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: read

jobs:
  update_headers:
    # Skip if the event was triggered by the bot's own auto-commit so we don't loop.
    # Also skip if the PR has the "maintanance" label (case-insensitive).
    if: ${{ github.actor != 'vestige-bot' && github.actor != 'vestige-bot[bot]' && !contains(fromJSON('["maintanance", "Maintanance", "MAINTANANCE"]'), github.event.pull_request.labels.*.name) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          token: ${{ secrets.WEH_BOT_PAT }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
        shell: bash

      - name: Resolve bot identity
        id: bot_id
        env:
          VAR_USER: ${{ vars.WEH_BOT_USERNAME }}
          VAR_EMAIL: ${{ vars.WEH_BOT_EMAIL }}
        run: |
          set -euo pipefail
          NAME="${VAR_USER:-}"
          EMAIL="${VAR_EMAIL:-}"
          if [ -z "$NAME" ]; then NAME="vestige-bot"; fi
          if [ -z "$EMAIL" ]; then EMAIL="vestige-bot@users.noreply.github.com"; fi
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "email=$EMAIL" >> $GITHUB_OUTPUT
        shell: bash

      - name: Get Changed Files and PR Info
        id: changed_files
        env:
           PR_BODY: ${{ github.event.pull_request.body }}
           GH_TOKEN: ${{ secrets.WEH_BOT_PAT }}
           GH_REPO: ${{ github.repository }}
           PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -e # Exit script on first error

          echo "Fetching files for PR #${PR_NUMBER} in repo ${GH_REPO}"

          PR_FILES_JSON=$(curl -s -f -H "Authorization: token ${GH_TOKEN}" \
            "https://api.github.com/repos/${GH_REPO}/pulls/${PR_NUMBER}/files")

          if [ $? -ne 0 ]; then
            echo "Error fetching PR files from GitHub API."
            exit 1
          fi

          if ! echo "$PR_FILES_JSON" | jq -e . > /dev/null; then
             echo "Warning: Received empty or invalid JSON from GitHub API for PR files."
             PR_FILES="" # Set PR_FILES to empty to avoid errors below
          else
             PR_FILES=$(echo "$PR_FILES_JSON" | jq -r '.[] | select(.filename != null) | "\(.status) \(.filename)"')
          fi

          if [ -z "$PR_FILES" ]; then
            echo "No files found in PR."
            ADDED_FILES=""
            MODIFIED_FILES=""
          else
            ADDED_FILES=$(echo "$PR_FILES" | grep "^added" | grep -E '\.(cs|ya?ml)$' | sed 's/^added //' | xargs) || true
            MODIFIED_FILES=$(echo "$PR_FILES" | grep "^modified" | grep -E '\.(cs|ya?ml)$' | sed 's/^modified //' | xargs) || true
          fi

          echo "Added Files: $ADDED_FILES"
          echo "Modified Files: $MODIFIED_FILES"

          echo "ADDED_FILES_LIST<<EOF" >> $GITHUB_ENV
          echo "$ADDED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "MODIFIED_FILES_LIST<<EOF" >> $GITHUB_ENV
          echo "$MODIFIED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "Checking PR body for license..."
          if grep -q "LICENSE: MIT" <<< "$PR_BODY"; then
            echo "PR_LICENSE=mit" >> $GITHUB_ENV
            echo "License specified in PR: MIT"
          elif grep -q "LICENSE: AGPL" <<< "$PR_BODY"; then
            echo "PR_LICENSE=agpl" >> $GITHUB_ENV
            echo "License specified in PR: AGPL"
          elif grep -q "LICENSE: MPL" <<< "$PR_BODY"; then
            echo "PR_LICENSE=mpl" >> $GITHUB_ENV
            echo "License specified in PR: MPL"
          else
            # Default core code license policy is MIT.
            echo "PR_LICENSE=mit" >> $GITHUB_ENV
            echo "No license specified in PR, using default: MIT"
          fi

          # Output whether we have any relevant files so later steps can be conditional.
          if [ -z "$ADDED_FILES" ] && [ -z "$MODIFIED_FILES" ]; then
            echo "has_files=false" >> $GITHUB_OUTPUT
          else
            echo "has_files=true" >> $GITHUB_OUTPUT
          fi
      - name: No candidate files - nothing to do
        if: ${{ steps.changed_files.outputs.has_files == 'false' }}
        run: echo "No added or modified *.cs / *.yml files to process. Skipping header update."

      - name: Run REUSE Header Update Script
        if: ${{ steps.changed_files.outputs.has_files == 'true' }}
        env:
          REUSE_FORCE_LICENSE: "true"  # Ensure existing headers are realigned to path rules
        run: |
          python Tools/update_pr_reuse_headers.py \
            --files-added ${{ env.ADDED_FILES_LIST }} \
            --files-modified ${{ env.MODIFIED_FILES_LIST }} \
            --pr-license ${{ env.PR_LICENSE }} \
            --pr-base-sha ${{ github.event.pull_request.base.sha }} \
            --pr-head-sha ${{ github.event.pull_request.head.sha }} \
            --pr-author ${{ github.event.pull_request.user.login }}
        working-directory: ${{ github.workspace }}

      - name: Commit changes
        if: ${{ steps.changed_files.outputs.has_files == 'true' }}
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: automatically update REUSE headers"
          commit_user_name: ${{ steps.bot_id.outputs.name }}
          commit_user_email: ${{ steps.bot_id.outputs.email }}
          commit_author: ${{ steps.bot_id.outputs.name }} <${{ steps.bot_id.outputs.email }}>
          skip_dirty_check: false
          skip_fetch: true
